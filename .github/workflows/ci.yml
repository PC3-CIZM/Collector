name: CI

on:
  # La CI se lance à chaque push sur develop
  push:
    branches: [ test ]
  # Et à chaque Pull Request vers develop
  pull_request:
    branches: [ test ]

jobs:
  # =========================
  # 1) JOB BACKEND
  # =========================
  backend:
    name: Backend CI
    runs-on: ubuntu-latest   # GitHub lance une VM Ubuntu

    # Toutes les commandes "run" se font dans le dossier backend/
    defaults:
      run:
        working-directory: backend

    steps:
      # 1. Récupérer le code du repo
      - name: Checkout repository
        uses: actions/checkout@v4

      # 2. Installer Node.js (version 20) dans la VM
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm
          cache-dependency-path: backend/package-lock.json

      # 3. Installer les dépendances du backend (à partir de package-lock.json)
      - name: Install dependencies
        run: npm ci

      # 4. Lancer le lint SI le script existe dans package.json
      #    continue-on-error: true => même si eslint trouve des erreurs,
      #    le job continue (la CI ne devient pas rouge à cause du lint).
      - name: Lint (si le script existe - n'empêche pas la CI)
        run: npm run lint --if-present
        continue-on-error: true

      # 5. Build du backend (transpile TypeScript, etc.) SI le script existe
      #    Si le build casse => le job échoue (normal, c'est bloquant).
      - name: Build (si le script existe)
        run: npm run build --if-present

  # =========================
  # 2) JOB FRONTEND
  # =========================
  frontend:
    name: Frontend CI
    runs-on: ubuntu-latest

    # Toutes les commandes "run" se font dans le dossier frontend/
    defaults:
      run:
        working-directory: frontend

    steps:
      # 1. Récupérer le code
      - name: Checkout repository
        uses: actions/checkout@v4

      # 2. Installer Node.js
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm
          cache-dependency-path: frontend/package-lock.json

      # 3. Installer les dépendances du frontend
      - name: Install dependencies
        run: npm ci

      # 4. Lancer le lint (non bloquant, comme pour le backend)
      - name: Lint (si le script existe - n'empêche pas la CI)
        run: npm run lint --if-present
        continue-on-error: true

      # 5. Build du frontend (Vite, etc.)
      - name: Build (si le script existe)
        run: npm run build --if-present

  # =========================
  # 3) JOB DOCKER : build + push des images dans GHCR
  # =========================
  docker-build:
    name: Build & push Docker images
    runs-on: ubuntu-latest

    # Ce job n'est lancé que si backend ET frontend ont réussi
    needs: [backend, frontend]

    # On donne le droit d'écrire dans GitHub Packages (GHCR)
    permissions:
      contents: read
      packages: write

    env:
      # Noms des images dans GHCR (org = pc3-cizm)
      IMAGE_BACKEND: ghcr.io/pc3-cizm/collector-backend
      IMAGE_FRONTEND: ghcr.io/pc3-cizm/collector-frontend

    steps:
      # 1. Récupérer le code (on repart d'un checkout propre)
      - name: Checkout repository
        uses: actions/checkout@v4

      # 2. Login à GitHub Container Registry (GHCR)
      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # 3. Build + tag de l'image backend
      - name: Build backend image
        run: |
          docker build -t $IMAGE_BACKEND:${{ github.sha }} ./backend
          docker tag $IMAGE_BACKEND:${{ github.sha }} $IMAGE_BACKEND:test

      # 4. Build + tag de l'image frontend
      - name: Build frontend image
        run: |
          docker build -t $IMAGE_FRONTEND:${{ github.sha }} ./frontend
          docker tag $IMAGE_FRONTEND:${{ github.sha }} $IMAGE_FRONTEND:test

      # 5. Push des images backend vers GHCR
      - name: Push backend images
        run: |
          docker push $IMAGE_BACKEND:${{ github.sha }}
          docker push $IMAGE_BACKEND:test

      # 6. Push des images frontend vers GHCR
      - name: Push frontend images
        run: |
          docker push $IMAGE_FRONTEND:${{ github.sha }}
          docker push $IMAGE_FRONTEND:test

      # 7. Afficher les images locales dans les logs
      - name: List built images
        run: docker images | grep collector || true

  # =========================
  # 4) JOB DB : vérification base de données
  # =========================
  db-check:
    name: Database CI
    runs-on: ubuntu-latest

    # On lance un conteneur PostgreSQL dédié pour la CI
    services:
      postgres:
        image: postgres:16
        env:
          POSTGRES_USER: collector_user
          POSTGRES_PASSWORD: SuperSecretP@ssw0rd2025!
          POSTGRES_DB: collector_db
        ports:
          - 5432:5432
        # On ajoute un healthcheck pour attendre que Postgres soit prêt
        options: >-
          --health-cmd="pg_isready -U collector_user -d collector_db"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=5

    steps:
      # 1. Récupérer le code du repo
      - name: Checkout repository
        uses: actions/checkout@v4

      # 2. Installer le client psql pour pouvoir parler à Postgres
      - name: Install psql client
        run: |
          sudo apt-get update
          sudo apt-get install -y postgresql-client

      # 3. Attendre que la base soit bien prête
      - name: Wait for database to be ready
        env:
          PGPASSWORD: SuperSecretP@ssw0rd2025!
        run: |
          for i in {1..10}; do
            pg_isready -h localhost -p 5432 -d collector_db -U collector_user && break
            echo "Database not ready yet, waiting..."
            sleep 3
          done

      # 4. Exécuter docker/init.sql si le fichier existe (création tables, données, etc.)
      - name: Apply init.sql (if exists)
        env:
          PGPASSWORD: SuperSecretP@ssw0rd2025!
        run: |
          if [ -f docker/init.sql ]; then
            echo "Found docker/init.sql, applying it..."
            psql -h localhost -p 5432 -U collector_user -d collector_db -f docker/init.sql
          else
            echo "No docker/init.sql file, skipping schema init"
          fi

      # 5. Faire une requête simple pour vérifier que la DB répond
      - name: Run simple smoke query
        env:
          PGPASSWORD: SuperSecretP@ssw0rd2025!
        run: |
          psql -h localhost -p 5432 -U collector_user -d collector_db -c "SELECT 1;"
