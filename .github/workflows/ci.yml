name: CI

on:
  # La CI se lance à chaque push sur develop
  push:
    branches: [ develop ]
  # Et à chaque Pull Request vers develop
  pull_request:
    branches: [ develop ]

jobs:
  # =========================
  # 1) JOB BACKEND
  # =========================
  backend:
    name: Backend CI
    runs-on: ubuntu-latest   # GitHub lance une VM Ubuntu

    # Toutes les commandes "run" se font dans le dossier backend/
    defaults:
      run:
        working-directory: backend

    steps:
      # 1. Récupérer le code du repo
      - name: Checkout repository
        uses: actions/checkout@v4

      # 2. Installer Node.js (version 20) dans la VM
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm
          cache-dependency-path: backend/package-lock.json

      # 3. Installer les dépendances du backend (à partir de package-lock.json)
      - name: Install dependencies
        run: npm ci

      # 4. Lancer le lint SI le script existe dans package.json
      #    continue-on-error: true => même si eslint trouve des erreurs,
      #    le job continue (la CI ne devient pas rouge à cause du lint).
      - name: Lint (si le script existe - n'empêche pas la CI)
        run: npm run lint --if-present
        continue-on-error: true

      # 5. Build du backend (transpile TypeScript, etc.) SI le script existe
      #    Si le build casse => le job échoue (normal, c'est bloquant).
      - name: Build (si le script existe)
        run: npm run build --if-present

  # =========================
  # 2) JOB FRONTEND
  # =========================
  frontend:
    name: Frontend CI
    runs-on: ubuntu-latest

    # Toutes les commandes "run" se font dans le dossier frontend/
    defaults:
      run:
        working-directory: frontend

    steps:
      # 1. Récupérer le code
      - name: Checkout repository
        uses: actions/checkout@v4

      # 2. Installer Node.js
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm
          cache-dependency-path: frontend/package-lock.json

      # 3. Installer les dépendances du frontend
      - name: Install dependencies
        run: npm ci

      # 4. Lancer le lint (non bloquant, comme pour le backend)
      - name: Lint (si le script existe - n'empêche pas la CI)
        run: npm run lint --if-present
        continue-on-error: true

      # 5. Build du frontend (Vite, etc.)
      - name: Build (si le script existe)
        run: npm run build --if-present

  # =========================
  # 3) JOB DOCKER : build des images
  # =========================
  docker-build:
    name: Build Docker images
    runs-on: ubuntu-latest

    # Ce job n'est lancé que si backend ET frontend ont réussi
    needs: [backend, frontend]

    steps:
      # 1. Récupérer le code (on repart d'un checkout propre)
      - name: Checkout repository
        uses: actions/checkout@v4

      # 2. (Facultatif) Connexion à un registry Docker
      #    Pour l'instant on ne push pas les images, donc on ne se logue pas.
      #    Si tu veux pousser plus tard, tu pourras utiliser DOCKERHUB_USERNAME/PASSWORD
      #    stockés dans les "Secrets" GitHub.
      # - name: Login to Docker Hub
      #   uses: docker/login-action@v3
      #   with:
      #     username: ${{ secrets.DOCKERHUB_USERNAME }}
      #     password: ${{ secrets.DOCKERHUB_TOKEN }}

      # 3. Build de l'image Docker du backend
      #    -t collector-backend:${{ github.sha }} => nom de l'image + tag = identifiant du commit
      - name: Build backend image
        run: docker build -t collector-backend:${{ github.sha }} ./backend

      # 4. Build de l'image Docker du frontend
      - name: Build frontend image
        run: docker build -t collector-frontend:${{ github.sha }} ./frontend

      # 5. Afficher la liste des images présentes dans la VM CI
      #    (ça te permet de voir les images dans les logs GitHub Actions)
      - name: List built images
        run: docker images | grep collector || true

  # =========================
  # 4) JOB DB : vérification base de données
  # =========================
  db-check:
    name: Database CI
    runs-on: ubuntu-latest

    # On lance un conteneur PostgreSQL dédié pour la CI
    services:
      postgres:
        image: postgres:16
        env:
          POSTGRES_USER: collector_user
          POSTGRES_PASSWORD: SuperSecretP@ssw0rd2025!
          POSTGRES_DB: collector_db
        ports:
          - 5432:5432
        # On ajoute un healthcheck pour attendre que Postgres soit prêt
        options: >-
          --health-cmd="pg_isready -U collector_user -d collector_db"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=5

    steps:
      # 1. Récupérer le code du repo
      - name: Checkout repository
        uses: actions/checkout@v4

      # 2. Installer le client psql pour pouvoir parler à Postgres
      - name: Install psql client
        run: |
          sudo apt-get update
          sudo apt-get install -y postgresql-client

      # 3. Attendre que la base soit bien prête
      - name: Wait for database to be ready
        env:
          PGPASSWORD: SuperSecretP@ssw0rd2025!
        run: |
          for i in {1..10}; do
            pg_isready -h localhost -p 5432 -d collector_db -U collector_user && break
            echo "Database not ready yet, waiting..."
            sleep 3
          done

      # 4. Exécuter docker/init.sql si le fichier existe (création tables, données, etc.)
      - name: Apply init.sql (if exists)
        env:
          PGPASSWORD: SuperSecretP@ssw0rd2025!
        run: |
          if [ -f docker/init.sql ]; then
            echo "Found docker/init.sql, applying it..."
            psql -h localhost -p 5432 -U collector_user -d collector_db -f docker/init.sql
          else
            echo "No docker/init.sql file, skipping schema init"
          fi

      # 5. Faire une requête simple pour vérifier que la DB répond
      - name: Run simple smoke query
        env:
          PGPASSWORD: SuperSecretP@ssw0rd2025!
        run: |
          psql -h localhost -p 5432 -U collector_user -d collector_db -c "SELECT 1;"
